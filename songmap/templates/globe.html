<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Global Music Trends Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #chartPane {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5); 
            color: white;
            font-family: 'Roboto', sans-serif;
            width: 350px; 
            height: 200px; 
            overflow: hidden; 
        }

        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1;
            background-color: rgba(0, 0, 0, 0.7); 
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
            color: white;
            font-family: 'Roboto', sans-serif;
        }

        #controls label {
            display: block;
            font-size: 14px;
            margin-bottom: 5px;
            color: #f0f0f0; 
        }

        #featureSelector {
            width: 100%;
            padding: 5px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            box-shadow: inset 0px 2px 5px rgba(0, 0, 0, 0.2);
        }

        #dateSlider {
            width: 90%;
            margin: 10px 0;
        }

        #dateDisplay {
            display: inline-block;
            margin-left: 5px;
            font-size: 14px;
            color: #f0f0f0;
        }

        #sliderIcons {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-top: -10px;
        }
        #infoPanel {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1;
        background-color: rgba(0, 0, 0, 0.7); 
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5); 
        color: white;
        font-family: 'Roboto', sans-serif; 
        width: 320px; 
        max-height: 90vh;
        overflow-y: auto;
    }

    #infoPanel h3 {
        font-size: 16px;
        font-weight: bold;
        margin: 0; 
        display: inline; 
        color: #f0f0f0;
    }

    #infoPanel .date {
        font-size: 14px;
        margin-left: 10px; 
        color: #aaa; 
    }

    #infoPanel table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
        background-color: rgba(255, 255, 255, 0.1); 
    }

    #infoPanel table th, #infoPanel table td {
        padding: 8px;
        text-align: left;
        font-size: 12px;
        color: #f0f0f0; 
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    #infoPanel table th {
        font-weight: bold;
        color: #ddd;
    }

    #infoPanel .divider {
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        margin: 10px 0;
    }

    #wordCloudContainer {
        width: 100%;
        height: 100px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 15px;
    }


        #divider {
            border-top: 1px solid #ccc;
            margin: 15px 0;
        }


    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "//unpkg.com/three/build/three.module.js",
                "three/addons/": "//unpkg.com/three/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        window.THREE = THREE;
    </script>
    <script src="//unpkg.com/three-globe" defer></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-cloud/build/d3.layout.cloud.min.js"></script>


</head>
<body>
    <div id="controls">
        <label for="featureSelector">Select Feature:</label>
        <select id="featureSelector">
        </select>
        <br><br>
        <label for="dateSlider">Select Date:</label>
        <input type="range" id="dateSlider" min="0" max="0" value="0" step="1">
        <div id="sliderIcons">
            <span>← Older</span>
            <span>Newer →</span>
        </div>
        <span id="dateDisplay"></span>
    </div>
    <div id="infoPanel"></div>
    <div id="chartPane"></div>

    <div id="globeViz"></div>
    <script type="module">
        import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
        let currentCountry = null;
        let selectedFeature = 'avgEnergy'; 
        let selectedDate = null; 
        let aggregatedData = {};
        const colorScale = d3.scaleSequential(d3.interpolateYlOrRd).domain([0, 1]);
        const originalColors = {};
        let hoveredPolygon = null;
        const Globe = new ThreeGlobe();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('globeViz').appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.add(Globe);
        scene.add(new THREE.AmbientLight(0xcccccc));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(0, 1, 1);
        scene.add(directionalLight);


        const camera = new THREE.PerspectiveCamera();
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        camera.position.z = 300;

        const tbControls = new TrackballControls(camera, renderer.domElement);
        tbControls.minDistance = 101;
        tbControls.rotateSpeed = 5;
        tbControls.zoomSpeed = 0.8;


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const countryNameToCode = {
            "Afghanistan": "AF",
            "Albania": "AL",
            "Algeria": "DZ",
            "Andorra": "AD",
            "Angola": "AO",
            "Antigua and Barbuda": "AG",
            "Argentina": "AR",
            "Armenia": "AM",
            "Australia": "AU",
            "Austria": "AT",
            "Azerbaijan": "AZ",
            "Bahamas": "BS",
            "Bahrain": "BH",
            "Bangladesh": "BD",
            "Barbados": "BB",
            "Belarus": "BY",
            "Belgium": "BE",
            "Belize": "BZ",
            "Benin": "BJ",
            "Bhutan": "BT",
            "Bolivia": "BO",
            "Bosnia and Herzegovina": "BA",
            "Botswana": "BW",
            "Brazil": "BR",
            "Brunei": "BN",
            "Bulgaria": "BG",
            "Burkina Faso": "BF",
            "Burundi": "BI",
            "Cambodia": "KH",
            "Cameroon": "CM",
            "Canada": "CA",
            "Cape Verde": "CV",
            "Central African Republic": "CF",
            "Chad": "TD",
            "Chile": "CL",
            "China": "CN",
            "Colombia": "CO",
            "Comoros": "KM",
            "Congo (Brazzaville)": "CG",
            "Congo (Kinshasa)": "CD",
            "Costa Rica": "CR",
            "Côte d'Ivoire": "CI",
            "Croatia": "HR",
            "Cuba": "CU",
            "Cyprus": "CY",
            "Czech Republic": "CZ",
            "Denmark": "DK",
            "Djibouti": "DJ",
            "Dominica": "DM",
            "Dominican Republic": "DO",
            "East Timor (Timor-Leste)": "TL",
            "Ecuador": "EC",
            "Egypt": "EG",
            "El Salvador": "SV",
            "Equatorial Guinea": "GQ",
            "Eritrea": "ER",
            "Estonia": "EE",
            "Eswatini": "SZ",
            "Ethiopia": "ET",
            "Fiji": "FJ",
            "Finland": "FI",
            "France": "FR",
            "Gabon": "GA",
            "Gambia": "GM",
            "Georgia": "GE",
            "Germany": "DE",
            "Ghana": "GH",
            "Greece": "GR",
            "Grenada": "GD",
            "Guatemala": "GT",
            "Guinea": "GN",
            "Guinea-Bissau": "GW",
            "Guyana": "GY",
            "Haiti": "HT",
            "Honduras": "HN",
            "Hungary": "HU",
            "Iceland": "IS",
            "India": "IN",
            "Indonesia": "ID",
            "Iran": "IR",
            "Iraq": "IQ",
            "Ireland": "IE",
            "Israel": "IL",
            "Italy": "IT",
            "Jamaica": "JM",
            "Japan": "JP",
            "Jordan": "JO",
            "Kazakhstan": "KZ",
            "Kenya": "KE",
            "Kiribati": "KI",
            "Korea, North": "KP",
            "Korea, South": "KR",
            "Kuwait": "KW",
            "Kyrgyzstan": "KG",
            "Laos": "LA",
            "Latvia": "LV",
            "Lebanon": "LB",
            "Lesotho": "LS",
            "Liberia": "LR",
            "Libya": "LY",
            "Liechtenstein": "LI",
            "Lithuania": "LT",
            "Luxembourg": "LU",
            "Madagascar": "MG",
            "Malawi": "MW",
            "Malaysia": "MY",
            "Maldives": "MV",
            "Mali": "ML",
            "Malta": "MT",
            "Marshall Islands": "MH",
            "Mauritania": "MR",
            "Mauritius": "MU",
            "Mexico": "MX",
            "Micronesia": "FM",
            "Moldova": "MD",
            "Monaco": "MC",
            "Mongolia": "MN",
            "Montenegro": "ME",
            "Morocco": "MA",
            "Mozambique": "MZ",
            "Myanmar": "MM",
            "Namibia": "NA",
            "Nauru": "NR",
            "Nepal": "NP",
            "Netherlands": "NL",
            "New Zealand": "NZ",
            "Nicaragua": "NI",
            "Niger": "NE",
            "Nigeria": "NG",
            "North Macedonia": "MK",
            "Norway": "NO",
            "Oman": "OM",
            "Pakistan": "PK",
            "Palau": "PW",
            "Panama": "PA",
            "Papua New Guinea": "PG",
            "Paraguay": "PY",
            "Peru": "PE",
            "Philippines": "PH",
            "Poland": "PL",
            "Portugal": "PT",
            "Qatar": "QA",
            "Romania": "RO",
            "Russia": "RU",
            "Rwanda": "RW",
            "Saint Kitts and Nevis": "KN",
            "Saint Lucia": "LC",
            "Saint Vincent and the Grenadines": "VC",
            "Samoa": "WS",
            "San Marino": "SM",
            "Sao Tome and Principe": "ST",
            "Saudi Arabia": "SA",
            "Senegal": "SN",
            "Serbia": "RS",
            "Seychelles": "SC",
            "Sierra Leone": "SL",
            "Singapore": "SG",
            "Slovakia": "SK",
            "Slovenia": "SI",
            "Solomon Islands": "SB",
            "Somalia": "SO",
            "South Africa": "ZA",
            "Spain": "ES",
            "Sri Lanka": "LK",
            "Sudan": "SD",
            "Sudan, South": "SS",
            "Suriname": "SR",
            "Sweden": "SE",
            "Switzerland": "CH",
            "Syria": "SY",
            "Taiwan": "TW",
            "Tajikistan": "TJ",
            "Tanzania": "TZ",
            "Thailand": "TH",
            "Togo": "TG",
            "Tonga": "TO",
            "Trinidad and Tobago": "TT",
            "Tunisia": "TN",
            "Turkey": "TR",
            "Turkmenistan": "TM",
            "Tuvalu": "TV",
            "Uganda": "UG",
            "Ukraine": "UA",
            "United Arab Emirates": "AE",
            "United Kingdom": "GB",
            "United States of America": "US",
            "Uruguay": "UY",
            "Uzbekistan": "UZ",
            "Vanuatu": "VU",
            "Vatican City": "VA",
            "Venezuela": "VE",
            "Vietnam": "VN",
            "Yemen": "YE",
            "Zambia": "ZM",
            "Zimbabwe": "ZW"
        };

        fetch('https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json')
            .then(res => res.json())
            .then(countries => {
                console.log('Countries GeoJSON:', countries);
                countries.features.forEach((feature) => {
                    if (feature.properties.iso_a3 === "USA") {
                        feature.properties.iso_a3 = "US"; 
                    }
                });
                // no need to create mapping here since we have countryNameToCode
                //reduce latency with async load
                Promise.all([
                    d3.csv('static/universal_top_spotify_songs.csv'),
                    d3.csv('static/lyrics_data.csv'),
                    d3.csv('static/song_lyric_word_dict.csv'),
                    d3.csv('static/song_data_with_mood_scores.csv')
                ]).then(([ds1Data, ds2Data, wordCloudData, moodScoreData]) => {
                    console.log('DS1 Data:', ds1Data);
                    console.log('DS2 Data:', ds2Data);
                    console.log('Word Cloud Data:', wordCloudData);
                    console.log('Mood Score Data:', moodScoreData);

                    //  store word cloud data globally
                    wordCloudData.forEach((entry) => {
                        entry.word_dictionary = JSON.parse(entry.word_dictionary.replace(/""/g, '"'));
                    });
                    window.wordCloudDataset = wordCloudData;

                    ds1Data = ds1Data.map(d => {
                        if (!d.country || d.country.trim() === '') {
                            d.country = 'Unknown';
                        }
                        return d;
                    });

                    // merg ds1Data and ds2Data based on spotify_id
                    const ds2Map = new Map(ds2Data.map(d => [d.spotify_id, d]));
                    const mergedDs1Ds2 = ds1Data.map(d => ({
                        ...d,
                        ...ds2Map.get(d.spotify_id)
                    }));

                    console.log('Merged DS1 and DS2:', mergedDs1Ds2);


                    const moodScoreMap = new Map(moodScoreData.map(d => [d.spotify_id, d]));
                    const unifiedData = mergedDs1Ds2.map(d => ({
                        ...d,
                        ...moodScoreMap.get(d.spotify_id)
                    }));

                    console.log('Unified Data (DS1, DS2, and Mood Scores):', unifiedData);


                    const filteredData = unifiedData.filter(d => d.country && d.country !== 'Unknown');

                    const countryDateData = d3.group(filteredData, d => d.country, d => d.snapshot_date);

                    aggregatedData = {};
                    countryDateData.forEach((dates, country) => {
                        aggregatedData[country] = {};
                        dates.forEach((records, date) => {
                            const parseValue = v => v === '' || v == null ? null : +v;


                            const energies = records.map(d => parseValue(d.energy)).filter(v => v != null);
                            const danceabilities = records.map(d => parseValue(d.danceability)).filter(v => v != null);
                            const valences = records.map(d => parseValue(d.valence)).filter(v => v != null);

                            const moodFeatures = [
                                'anger', 'anticipation', 'disgust', 'fear', 'joy',
                                'negative', 'positive', 'sadness', 'surprise', 'trust'
                            ];

                            if (!window.moodFeatureStats) {
                                window.moodFeatureStats = moodFeatures.reduce((stats, feature) => {
                                    const allValues = filteredData
                                        .map((d) => parseValue(d[feature]))
                                        .filter((v) => v != null && v > 0); // Log scale requires positive values

                                    const minLog = d3.min(allValues.map(Math.log));
                                    const maxLog = d3.max(allValues.map(Math.log));

                                    stats[feature] = { minLog, maxLog }; // Store log-transformed min and max
                                    return stats;
                                }, {});
                            }





  
                            const moodAverages = {};
                            moodFeatures.forEach((feature) => {
                                const values = records
                                    .map((d) => parseValue(d[feature]))
                                    .filter((v) => v != null && v > 0); // Ensure positive values for log

                                if (values.length) {
                                    const avg = d3.mean(values);
                                    const avgLog = Math.log(avg);

                                    const { minLog, maxLog } = window.moodFeatureStats[feature];

                                    moodAverages[feature] = Math.round(
                                        ((avgLog - minLog) / (maxLog - minLog)) * 205 + 50
                                    );
                                } else {
                                    moodAverages[feature] = null; // Default to null if no valid data
                                }
                            });




                            aggregatedData[country][date] = {
                                avgEnergy: energies.length ? d3.mean(energies) : null,
                                avgDanceability: danceabilities.length ? d3.mean(danceabilities) : null,
                                avgValence: valences.length ? d3.mean(valences) : null,
                                ...moodAverages,
                                topSongs: records.sort((a, b) => a.daily_rank - b.daily_rank).slice(0, 10)
                            };
                        });
                    });

                    console.log('Aggregated Data:', aggregatedData);

                    // Set up date picker with available dates
                    const availableDates = Array.from(new Set(ds1Data.map(d => d.snapshot_date))).filter(d => d && d !== '');
                    availableDates.sort();
                    console.log('Available Dates:', availableDates);

                    if (availableDates.length === 0) {
                        alert('No available dates found in the data.');
                        return;
                    }
                    selectedDate = availableDates[0];
                    const dateSlider = document.getElementById('dateSlider');
                    const dateDisplay = document.getElementById('dateDisplay');

                    dateSlider.min = 0;
                    dateSlider.max = availableDates.length - 1;
                    dateSlider.value = availableDates.indexOf(selectedDate);


                    dateDisplay.textContent = selectedDate;


                    /*
                    dateSlider.addEventListener('input', function(event) {
                        const index = +event.target.value;
                        selectedDate = availableDates[index];
                        dateDisplay.textContent = selectedDate;
                        updateCountryColors();
                    });
                    */


                    Globe.globeImageUrl('//unpkg.com/three-globe/example/img/earth-dark.jpg')
                        .hexPolygonsData(countries.features)
                        .hexPolygonResolution(3) 
                        .hexPolygonMargin(0) 
                        .hexPolygonAltitude(0.005); 

                    updateCountryColors();

                    //handlers
                    let selectedPolygon = null; 

                function onMouseMove(event) {
                    // Convert mouse position to normalized device coordinates
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                    // Update raycaster and find intersections
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(Globe.children, true);
                    
                    if (intersects.length) {
                        const intersectedObject = intersects[0].object;
                        const intersectedPolygon = intersectedObject.__data || intersectedObject.parent?.__data;
                        
                        if (intersectedPolygon && hoveredPolygon !== intersectedPolygon && intersectedPolygon !== selectedPolygon) {

                            if (hoveredPolygon && hoveredPolygon !== selectedPolygon) {
                                
                                
                                const prevObj = getMeshObjectForPolygon(hoveredPolygon);
                                const prevCountryName = getCountryNameFromPolygon(hoveredPolygon);
                                if (prevObj && originalColors[prevCountryName]) {
                                    prevObj.material.color.set(originalColors[prevCountryName]);
                                    prevObj.scale.set(1, 1, 1);
                                }

                            }


                            hoveredPolygon = intersectedPolygon;
                            Globe.hexPolygonAltitude((polygon) => {
                                if (polygon === selectedPolygon) {
                                    return 0.06; 
                                } else if (polygon === hoveredPolygon) {
                                    return 0.03;
                                } else {
                                    return 0.005; // default
                                }
                            });
                            Globe.hexPolygonMargin((polygon) => {
                                if (polygon === selectedPolygon) {
                                    return 0.05;
                                } else {
                                    return 0; 
                                }

                            }
                            
                            
                            )


                            if (hoveredPolygon !== selectedPolygon) {
                                const obj = getMeshObjectForPolygon(hoveredPolygon);
                                if (obj) {
                                    const countryName = getCountryNameFromPolygon(hoveredPolygon);
                                    if (!originalColors[countryName]) {
                                        originalColors[countryName] = obj.material.color.getStyle();
                                    }
                                    obj.material.color.set('rgb(255, 215, 0)');
                                    obj.scale.set(1.1, 1.1, 1.1); 
                                }
                            }
                        }
                    } else {
                        
                        if (hoveredPolygon && hoveredPolygon !== selectedPolygon) {
                            const obj = getMeshObjectForPolygon(hoveredPolygon);
                            const countryName = getCountryNameFromPolygon(hoveredPolygon);
                            if (obj && originalColors[countryName]) {
                                obj.material.color.set(originalColors[countryName]);
                                obj.scale.set(1, 1, 1);
                            }
                            hoveredPolygon = null;
                        }
                    }
                }

                let isDragging = false;
                let clickTimeout;

                //attempt to handle dragging vs. clicks
                window.addEventListener('mousedown', (event) => {
                    isDragging = false;
                    clickTimeout = setTimeout(() => {
                        isDragging = true; 
                    }, 200); 
                });

                window.addEventListener('mouseup', (event) => {
                    clearTimeout(clickTimeout);
                    if (!isDragging) {
                        onClick(event); 
                    }
                });

                function onClick(event) {

                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(Globe.children, true);

                    if (intersects.length) {
                        const intersectedObject = intersects[0].object;
                        const intersectedPolygon = intersectedObject.__data || intersectedObject.parent?.__data;

                        if (selectedPolygon && selectedPolygon !== intersectedPolygon) {
                            const prevSelectedObj = getMeshObjectForPolygon(selectedPolygon);
                            const prevSelectedCountry = getCountryNameFromPolygon(selectedPolygon);
                            if (prevSelectedObj && originalColors[prevSelectedCountry]) {
                                prevSelectedObj.material.color.set(originalColors[prevSelectedCountry]);
                                prevSelectedObj.scale.set(1, 1, 1); // reset scale
                            }
                        }

                        selectedPolygon = intersectedPolygon; 

                        // animations
                        Globe.hexPolygonAltitude((polygon) =>
                            polygon === selectedPolygon ? 0.06 : 0.005
                        );

                        if (selectedPolygon) {
                            const obj = getMeshObjectForPolygon(selectedPolygon);
                            if (obj) {
                                obj.material.color.set('rgb(0, 191, 255)'); 
                                obj.scale.set(1.2, 1.2, 1.2); 
                            }

                            const countryName = getCountryNameFromPolygon(selectedPolygon);
                            currentCountry = getCountryNameFromPolygon(selectedPolygon);
                            updateInfoPanel(countryName); 
                        }
                    }
                }
                    //event listeners
                    window.addEventListener('mousemove', onMouseMove);

                    // animation loop
                    function animate() {
                        tbControls.update();
                        renderer.render(scene, camera);
                        requestAnimationFrame(animate);
                    }
                    animate();


                    window.addEventListener('resize', () => {
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();
                    });

                    const featureSelector = document.getElementById('featureSelector');
                   
                    ['Energy', 'Danceability', 'Valence', 'RGB'].forEach((feature) => {
                        const option = document.createElement('option');
                        if (feature === 'RGB') {
                            option.value = 'RGB';
                            option.textContent = `Audio - ${feature}`;
                        } else {
                            option.value = `avg${feature}`; 
                            option.textContent = `Audio - ${feature}`;
                        }
                        featureSelector.appendChild(option);
                    });


                    ['anger', 'anticipation', 'disgust', 'fear', 'joy', 'negative', 'positive', 'sadness', 'surprise', 'trust'].forEach((feature) => {
                        const option = document.createElement('option');
                        option.value = feature; // Direct match to aggregatedData keys
                        option.textContent = `Lyrics - ${feature.charAt(0).toUpperCase() + feature.slice(1)}`;
                        featureSelector.appendChild(option);
                    });

                    featureSelector.addEventListener('change', (event) => {
                        selectedFeature = event.target.value;
                        console.log('Selected feature:', selectedFeature); // Debugging
                        updateCountryColors(); 
                        if (currentCountry) {
                            updateInfoPanel(currentCountry); 
                        }
                    });


                    let infoPanelUpdateTimeout; 
                    let datesliding = 0;
                    dateSlider.addEventListener('input', function (event) {
                        datesliding = 1;
                        const index = +event.target.value;
                        selectedDate = availableDates[index];
                        dateDisplay.textContent = selectedDate;

                        //immediate
                        updateCountryColors();

                        // async
                        if (infoPanelUpdateTimeout) {
                            clearTimeout(infoPanelUpdateTimeout);
                        }
                        infoPanelUpdateTimeout = setTimeout(() => {
                            if (currentCountry) {
                                updateInfoPanel(currentCountry);
                            }
                        }, 200); 
                    });


                    function getCountryNameFromPolygon(polygon) {
                        return polygon.properties.name;
                    }

                    // update colors
                    function updateCountryColors() {
                        console.log('Updating country colors for feature:', selectedFeature, 'and date:', selectedDate);

                        Globe.hexPolygonColor((polygon) => {
                            const countryName = getCountryNameFromPolygon(polygon);
                            const countryCode = countryNameToCode[countryName];

                            if (!countryCode) {
                                console.warn(`No country code found for ${countryName}`);
                                return '#ccc';
                            }

                            const countryData = aggregatedData[countryCode] && aggregatedData[countryCode][selectedDate];

                            if (countryData) {
                                if (selectedFeature === 'RGB') {
                                    // Handle RGB composite feature
                                    const r = Math.round((countryData.avgEnergy || 0) * 255);
                                    const g = Math.round((countryData.avgDanceability || 0) * 255);
                                    const b = Math.round((countryData.avgValence || 0) * 255);
                                    return `rgb(${r}, ${g}, ${b})`;
                                } else if (selectedFeature.startsWith('avg')) {
                                    // Handle audio features
                                    return countryData[selectedFeature] != null
                                        ? colorScale(countryData[selectedFeature])
                                        : '#ccc';
                                } else {
                                    // Handle lyric features
                                    const moodFeature = selectedFeature.toLowerCase();
                                    const normalizedValue = countryData[moodFeature];

                                    if (normalizedValue != null) {
                                        return `rgb(${255 - normalizedValue}, 40, ${255 - normalizedValue})`; // Include green channel for visibility
                                    } else {
                                        return `rgb(150, 150, 150)`; // Default gray for missing data
                                    }

                                }
                            }

                            return '#ccc'; // Default color
                        });
                    }



                    console.log(d3.layout);

                    function renderWordCloud(wordData, container) {
                    d3.select(container).selectAll('svg').remove();
                    const svg = d3.select(container)
                        .append('svg')
                        .attr('width', 300)
                        .attr('height', 300);

                    const layout = d3.layout.cloud()
                        .size([300, 300])
                        .words(
                            wordData.map(([word, size]) => ({
                                text: word,
                                size: size,
                            }))
                        )
                        .padding(5)
                        .rotate(() => (Math.random() > 0.5 ? 90 : 0))
                        .fontSize((d) => Math.log(d.size + 1) * 10)
                        .on('end', (words) => {
                            svg.append('g')
                                .attr('transform', 'translate(150,150)')
                                .selectAll('text')
                                .data(words)
                                .enter()
                                .append('text')
                                .style('font-size', (d) => `${d.size}px`)
                                .style('fill', () => d3.schemeCategory10[Math.floor(Math.random() * 10)])
                                .attr('text-anchor', 'middle')
                                .attr('transform', (d) => `translate(${d.x},${d.y})rotate(${d.rotate})`)
                                .text((d) => d.text);
                        });

                    layout.start();
                }

                    function updateInfoPanel(countryName) {
                        const countryCode = countryNameToCode[countryName];
                        const infoPanel = document.getElementById('infoPanel');

                        infoPanel.innerHTML = '';

                        if (!countryCode) {
                            infoPanel.innerHTML = `<h3>${countryName}</h3><p>No data available.</p>`;
                            return;
                        }

                        const countryData = aggregatedData[countryCode] && aggregatedData[countryCode][selectedDate];

                        if (!countryData) {
                            infoPanel.innerHTML = `<h3>${countryName}</h3><p>No data available for the selected date.</p>`;
                            return;
                        }

                        //  basic country info
                        let htmlContent = `
                            <div>
                                <h3>${countryName}</h3>
                                <span class="date">${selectedDate}</span>
                            </div>
                            <div class="divider"></div>
                        `;
                        if (selectedFeature.startsWith('Audio -')) {
                            htmlContent += `<p><strong>${selectedFeature}:</strong> ${countryData[selectedFeature.replace('Audio - ', 'avg').toLowerCase()] || 'N/A'}</p>`;
                        } else if (selectedFeature.startsWith('Lyrics -')) {
                            const moodFeature = selectedFeature.split(' - ')[1].toLowerCase();
                            htmlContent += `<p><strong>${selectedFeature}:</strong> ${countryData[moodFeature] || 'N/A'}</p>`;
                        }
                        htmlContent += `
                        <h4>Top 10 Songs:</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Song</th>
                                    <th>Artist</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${countryData.topSongs
                                    .sort((a, b) => a.daily_rank - b.daily_rank) 
                                    .slice(0, 10)
                                    .map((song, index) => `
                                        <tr>
                                            <td>${index + 1}</td>
                                            <td>${song.name}</td>
                                            <td>${song.artists}</td>
                                        </tr>
                                    `)
                                    .join('')}
                            </tbody>
                        </table>
                    `;


                        
                        
                        infoPanel.innerHTML = htmlContent;
                        //stupid way to deal with stopping chart updates
                        if (datesliding == 0) {    
                            const chartPane = document.getElementById('chartPane');
                            chartPane.innerHTML = '';

                            //chart
                            const canvas = document.createElement('canvas');
                            canvas.id = 'featureChart';
                            canvas.style.width = '100%'; 
                            canvas.style.height = '100%'; 
                            chartPane.appendChild(canvas);
                            const countryTimeSeries = aggregatedData[countryCode];
                            const dates = Object.keys(countryTimeSeries).sort();
                            const energies = dates.map(date => countryTimeSeries[date]?.avgEnergy || null);
                            const danceabilities = dates.map(date => countryTimeSeries[date]?.avgDanceability || null);
                            const valences = dates.map(date => countryTimeSeries[date]?.avgValence || null);

                            const rgbColors = dates.map((date, i) => {
                                const r = Math.round((energies[i] || 0) * 255);
                                const g = Math.round((danceabilities[i] || 0) * 255);
                                const b = Math.round((valences[i] || 0) * 255);
                                return `rgb(${r}, ${g}, ${b})`;
                            });

                            if (selectedFeature === 'RGB') {
                                const ctx = canvas.getContext('2d');
                                new Chart(ctx, {
                                    type: 'line',
                                    data: {
                                        labels: dates,
                                        datasets: [
                                            {
                                                label: 'Energy (Red)',
                                                data: energies,
                                                borderColor: 'rgba(255, 0, 0, 1)',
                                                backgroundColor: 'rgba(255, 0, 0, 0.2)',
                                                borderWidth: 2,
                                                tension: 0.3,
                                            },
                                            {
                                                label: 'Danceability (Green)',
                                                data: danceabilities,
                                                borderColor: 'rgba(0, 255, 0, 1)',
                                                backgroundColor: 'rgba(0, 255, 0, 0.2)',
                                                borderWidth: 2,
                                                tension: 0.3,
                                            },
                                            {
                                                label: 'Valence (Blue)',
                                                data: valences,
                                                borderColor: 'rgba(0, 0, 255, 1)',
                                                backgroundColor: 'rgba(0, 0, 255, 0.2)',
                                                borderWidth: 2,
                                                tension: 0.3,
                                            },
                                        ],
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            x: {
                                                title: {
                                                    display: true,
                                                    text: 'Date',
                                                    font: {size: 10,
                                                    },
                                                },
                                                ticks: {
                                                    font: {
                                                        size: 9,
                                                    },
                                                    callback: function(value, index, ticks) {
                                                        const originalDate = this.getLabelForValue(value); 
                                                        const dateParts = originalDate.split('-'); 
                                                        const formattedDate = `${dateParts[1]}/${dateParts[2]}/${dateParts[0].slice(-2)}`; // Format as MM/DD/YY
                                                        return formattedDate; // Return formatted date
                                                    },
                                                },
                                            },
                                            y: {
                                                beginAtZero: false,
                                                title: {
                                                    display: true,
                                                    text: 'Values',
                                                    font: {size: 9,
                                                    },
                                                },
                                                ticks: {
                                                    font: {
                                                        size: 9,
                                                    },
                                                },
                                            },
                                        },
                                        plugins: {
                                            legend: {
                                                display: true,
                                                position: 'top',
                                                labels: {
                                                    font: {
                                                        size: 10, 
                                                    },
                                                },
                                            },
                                        },
                                    },
                                });
                            } else {
                                const ctx = canvas.getContext('2d');
                                const featureValues = dates.map(
                                    (date) => countryTimeSeries[date]?.[selectedFeature] || null
                                );
                                const featureColor =
                                    selectedFeature === 'avgEnergy'
                                        ? 'rgba(255, 0, 0, 1)'
                                        : selectedFeature === 'avgDanceability'
                                        ? 'rgba(0, 255, 0, 1)'
                                        : 'rgba(0, 0, 255, 1)'; 

                                new Chart(ctx, {
                                    type: 'line',
                                    data: {
                                        labels: dates,
                                        datasets: [
                                            {
                                                label: selectedFeature.replace('avg', ''),
                                                data: featureValues,
                                                borderColor: featureColor,
                                                backgroundColor: featureColor.replace('1)', '0.2)'),
                                                borderWidth: 2,
                                                tension: 0.3,
                                            },
                                        ],
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            x: {
                                                title: {
                                                    display: true,
                                                    text: 'Date',
                                                    font: {size: 10,
                                                    },
                                                },
                                                ticks: {
                                                    font: {
                                                        size: 9,
                                                    },
                                                    callback: function(value, index, ticks) {
                                                        const originalDate = this.getLabelForValue(value); 
                                                        const dateParts = originalDate.split('-'); 
                                                        const formattedDate = `${dateParts[1]}/${dateParts[2]}/${dateParts[0].slice(-2)}`; // Format as MM/DD/YY
                                                        return formattedDate; // Return formatted date
                                                    },
                                                },
                                            },
                                            y: {
                                                beginAtZero: false,
                                                title: {
                                                    display: true,
                                                    text: 'Values',
                                                    font: {size: 9,
                                                    },
                                                },
                                                ticks: {
                                                    font: {
                                                        size: 9,
                                                    },
                                                },
                                            },
                                        },
                                        plugins: {
                                            legend: {
                                                display: true,
                                                position: 'top',
                                                labels: {
                                                    font: {
                                                        size: 10,
                                                    },
                                                },
                                            },
                                        },
                                        plugins: {
                                            //didnt work
                                            afterDraw: (chart) => {
                                                if (verticalLinePosition !== null) {
                                                    const ctx = chart.ctx;
                                                    const xAxis = chart.scales.x;
                                                    const xPos = xAxis.getPixelForValue(verticalLinePosition);
                                                  
                                                    ctx.save();
                                                    ctx.beginPath();
                                                    ctx.moveTo(xPos, chart.chartArea.top);
                                                    ctx.lineTo(xPos, chart.chartArea.bottom);
                                                    ctx.lineWidth = 2;
                                                    ctx.strokeStyle = 'gray';
                                                    ctx.stroke();
                                                    ctx.restore();
                                                }
                                            },
                                        },
                                    },
                                });
                            }
                        }
                        datesliding = 0;
                        const wordCloudData = wordCloudDataset.find(
                          (entry) => entry.country === countryCode && entry.snapshot_date === selectedDate
                        );

                        if (wordCloudData && wordCloudData.word_dictionary) {
                            console.log('Word Cloud Data:', wordCloudData);
                            const words = Object.entries(wordCloudData.word_dictionary).filter(
                                ([word, size]) => typeof word === 'string' && typeof size === 'number'
                            );

                            const wordCloudContainer = document.createElement('div');
                            wordCloudContainer.id = 'wordCloud';
                            wordCloudContainer.height = '30px'
                            infoPanel.appendChild(wordCloudContainer);

                            renderWordCloud(words, wordCloudContainer);
                        } else {
                            console.warn('No word cloud data found for this date and country.');
                            const noDataMessage = document.createElement('p');
                            noDataMessage.textContent = 'No word cloud data available.';
                            infoPanel.appendChild(noDataMessage);
                        }

                    
                    } 


                    // Helper function to get the mesh object for a polygon
                    function getMeshObjectForPolygon(polygon) {
                        const hexGroup = Globe.children.find(child => child.type === 'Group' && child.name === 'hexPolygons');
                        if (hexGroup) {
                            return hexGroup.children.find(child => child.__data === polygon);
                        }
                        return null;
                    }
                }).catch(err => console.error('Error loading datasets:', err));
            })
            .catch(err => console.error('Error loading GeoJSON:', err));
    </script>
</body>
</html>
